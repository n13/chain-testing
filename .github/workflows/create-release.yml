name: Create Release

env:
  CARGO_TERM_COLOR: always

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Type of version bump (major, minor, patch) or specify custom version. For 0.x.y releases, major will bump 0.x -> 0.(x+1)'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
          - custom
      custom_version:
        description: 'Custom version string (e.g., v1.2.3 or v0.2.1-beta.1). Only used if version_type is "custom". MUST start with "v" (e.g. v1.2.3)'
        required: false
      is_prerelease:
        description: 'Is this a pre-release? (e.g., alpha, beta, rc)'
        required: true
        type: boolean
        default: false
      prerelease_identifier:
        description: 'Pre-release identifier (e.g., alpha, beta, rc). Only used if is_prerelease is true.'
        required: false
        default: 'rc'
      draft_release:
        description: 'Create the release as a draft?'
        required: true
        type: boolean
        default: true
      fast_test_create_release_job:
        description: 'If true, skips actual build and uses dummy artifacts to test release creation steps.'
        required: false
        type: boolean
        default: false
      # Add an input for release notes if you want to paste them in manually
      # release_notes:
      #   description: 'Release notes content (Markdown)'
      #   required: false

jobs:
  calculate_next_version:
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.versioner.outputs.new_version }}
      commit_sha_short: ${{ steps.vars.outputs.commit_sha_short }}
      branch_name: ${{ steps.vars.outputs.branch_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get current branch and commit SHA
        id: vars
        run: |
          echo "commit_sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "branch_name=$(git rev-parse --abbrev-ref HEAD)" >> $GITHUB_OUTPUT

      - name: Get latest tag
        id: latest_tag
        run: |
          # Attempt to get the latest vX.Y.Z tag
          latest_semver_tag=$(git describe --tags --match "v[0-9]*.[0-9]*.[0-9]*" --abbrev=0 2>/dev/null || echo "v0.0.0")
          if [[ "$latest_semver_tag" == "v0.0.0" ]]; then
            # If no strict vX.Y.Z found, try to get any v* tag (e.g. v0.1.0-rc.1)
            # and then strip potential pre-release to get a base for bumping,
            # or fall back to v0.0.0 if still nothing.
            # This is a fallback, the awk script was meant to handle this more gracefully.
            latest_semver_tag=$(git describe --tags --match "v*" --abbrev=0 2>/dev/null | sed 's/-\(alpha\|beta\|rc\)\(\.[0-9]*\)?$//' || echo "v0.0.0")
          fi
          echo "latest_tag_found=$latest_semver_tag" >> $GITHUB_OUTPUT
          echo "Latest semantic version tag found: $latest_semver_tag"

      - name: Calculate new version
        id: versioner
        env:
          LATEST_TAG: ${{ steps.latest_tag.outputs.latest_tag_found }}
          VERSION_TYPE: ${{ github.event.inputs.version_type }}
          CUSTOM_VERSION: ${{ github.event.inputs.custom_version }}
          IS_PRERELEASE: ${{ github.event.inputs.is_prerelease }}
          PRERELEASE_ID: ${{ github.event.inputs.prerelease_identifier }}
        run: |
          # Remove \'v\' prefix for processing
          current_version=${LATEST_TAG#v}

          if [[ "$VERSION_TYPE" == "custom" ]]; then
            if [[ -z "$CUSTOM_VERSION" ]]; then
              echo "Error: Custom version is selected but no custom_version string provided."
              exit 1
            fi
            if [[ ! "$CUSTOM_VERSION" =~ ^v ]]; then
              echo "Error: Custom version string MUST start with \'v\' (e.g., v1.2.3)."
              exit 1
            fi
            new_version="$CUSTOM_VERSION"
          else
            # Split version and pre-release part
            IFS=\'-\' read -r version_core prerelease_part <<< "$current_version"
            IFS=\'.\' read -r major minor patch <<< "$version_core"

            # Increment based on type
            if [[ "$VERSION_TYPE" == "major" ]]; then
              if [[ "$major" == "0" ]]; then # Handle 0.x.y -> 0.(x+1).0
                major=$major
                minor=$((minor + 1))
                patch=0
              else
                major=$((major + 1))
                minor=0
                patch=0
              fi
            elif [[ "$VERSION_TYPE" == "minor" ]]; then
              minor=$((minor + 1))
              patch=0
            elif [[ "$VERSION_TYPE" == "patch" ]]; then
              patch=$((patch + 1))
            else
              echo "Error: Invalid version_type: $VERSION_TYPE"
              exit 1
            fi
            new_version_core="v$major.$minor.$patch"

            if [[ "$IS_PRERELEASE" == "true" ]]; then
              prerelease_num=1
              # If current was a prerelease of the same core and same ID, increment number
              if [[ "$prerelease_part" =~ ^$PRERELEASE_ID\\.([0-9]+)$ ]]; then
                # Check if base version matches after potential increment
                # This logic gets tricky if we bump minor/major and also want a prerelease
                # For simplicity, if major/minor/patch is bumped, new prerelease starts at .1
                # If only toggling IS_PRERELEASE or changing PRERELEASE_ID on same core, then consider incrementing.
                # Current logic: a new version bump (patch/minor/major) resets prerelease to .1
                prerelease_num=1 # Simplified: always start at .1 for new core version
              elif [[ "$prerelease_part" =~ ^$PRERELEASE_ID$ ]]; then
                 prerelease_num=1 # also start at .1 if it was just "alpha"
              fi
              new_version="$new_version_core-$PRERELEASE_ID.$prerelease_num"
            else
              new_version="$new_version_core"
            fi
          fi
          echo "New version: $new_version"
          echo "new_version=$new_version" >> $GITHUB_OUTPUT

  build_and_package:
    needs: calculate_next_version
    runs-on: ${{ matrix.os }} # Runs on the OS specified in the matrix
    strategy:
      matrix:
        # Define build targets and corresponding OS
        include:
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
          - target: aarch64-apple-darwin # Target for Apple Silicon Macs
            os: macos-latest # macos-latest can cross-compile or run ARM via Rosetta
    outputs:
      release_assets_json: ${{ steps.prepare_assets.outputs.release_assets_json }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install protoc (protobuf-compiler) for Linux
        if: runner.os == 'Linux'
        run: sudo apt-get update && sudo apt-get install -y protobuf-compiler

      - name: Install protoc (protobuf-compiler) for macOS
        if: runner.os == 'macOS'
        run: brew install protobuf

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: nightly-2024-12-24
          components: rustfmt, clippy, rust-src
          targets: wasm32-unknown-unknown, ${{ matrix.target }}

      - name: Cache Cargo dependencies
        uses: Swatinem/rust-cache@v2
        with:
          save-if: ${{ github.ref == 'refs/heads/main' }}
          prefix-key: v0-rust-${{ matrix.os }}-${{ matrix.target }}

      - name: Build quantus-node binary (if not fast testing)
        if: github.event.inputs.fast_test_create_release_job == 'false'
        run: cargo build --locked --release --package quantus-node --target ${{ matrix.target }}

      - name: Create dummy quantus-node binary (for fast test)
        if: github.event.inputs.fast_test_create_release_job == 'true'
        run: |
          mkdir -p target/${{ matrix.target }}/release
          echo "This is a dummy quantus-node for fast testing (${{ matrix.target }}). Actual build skipped." > target/${{ matrix.target }}/release/quantus-node
          chmod +x target/${{ matrix.target }}/release/quantus-node
          echo "Dummy quantus-node created at target/${{ matrix.target }}/release/quantus-node"

      - name: Prepare Release Assets
        id: prepare_assets
        env:
          NEW_VERSION: ${{ needs.calculate_next_version.outputs.new_version }}
          TARGET_ARCH: ${{ matrix.target }}
        run: |
          # Determine asset names based on version and target
          NODE_BINARY_NAME="quantus-node"
          asset_name="${NODE_BINARY_NAME}-${NEW_VERSION}-${TARGET_ARCH}.tar.gz"
          checksum_file_name="sha256sums-${NEW_VERSION}-${TARGET_ARCH}.txt"

          # Create staging directory for assets
          mkdir staging
          # Copy from target-specific path
          cp target/${TARGET_ARCH}/release/${NODE_BINARY_NAME} staging/
          
          # Create tarball
          (cd staging && tar -czvf "../${asset_name}" ${NODE_BINARY_NAME})
          
          # Generate checksum for the tarball
          if [[ "${{ runner.os }}" == "macOS" ]]; then
            shasum -a 256 "${asset_name}" > "${checksum_file_name}"
          else
            sha256sum "${asset_name}" > "${checksum_file_name}"
          fi
          
          echo "Created asset: ${asset_name}"
          echo "Created checksum file: ${checksum_file_name}"

          # Prepare JSON output for artifact upload and release creation
          # Storing paths relative to GITHUB_WORKSPACE
          asset_paths_json="[\\"${asset_name}\\", \\"${checksum_file_name}\\"]"
          echo "release_assets_json=${asset_paths_json}" >> $GITHUB_OUTPUT
          # List files for verification
          ls -la


      - name: Upload Release Assets as Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-assets-${{ matrix.target }}
          path: | 
            quantus-node-${{ needs.calculate_next_version.outputs.new_version }}-${{ matrix.target }}.tar.gz
            sha256sums-${{ needs.calculate_next_version.outputs.new_version }}-${{ matrix.target }}.txt

  create_github_release:
    needs: [calculate_next_version, build_and_package] 
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}

      - name: Download all release assets
        uses: actions/download-artifact@v4
        with:
          path: downloaded-artifacts # All artifacts extracted here, each in its own subdir
        # No 'name' specified, downloads all artifacts from previous jobs in this workflow run
        # This will create directories like 'downloaded-artifacts/release-assets-x86_64-unknown-linux-gnu/'
        # We'll need to find the files within these directories.

      - name: Generate asset list file
        run: |
          echo "--- Directory structure of downloaded-artifacts ---"
          ls -R downloaded-artifacts
          echo "--- Finding asset files ---"
          bash -c 'find downloaded-artifacts -type f \( -name "*.tar.gz" -o -name "*.txt" \) -print0' > asset_files.txt
          echo "--- Raw content of asset_files.txt (null characters will not be visible) ---"
          cat asset_files.txt 
          echo "--- Processed content of asset_files.txt (one file per line) ---"
          cat asset_files.txt | xargs -0 -n1
          echo "--- End of Generate asset list file step ---"

      - name: Create Git Tag
        env:
          NEW_VERSION: ${{ needs.calculate_next_version.outputs.new_version }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"
          git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
          git push origin "$NEW_VERSION"

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NEW_VERSION: ${{ needs.calculate_next_version.outputs.new_version }}
          COMMIT_SHA_SHORT: ${{ needs.calculate_next_version.outputs.commit_sha_short }}
          BRANCH_NAME: ${{ needs.calculate_next_version.outputs.branch_name }}
          IS_PRERELEASE: ${{ github.event.inputs.is_prerelease }}
          DRAFT_RELEASE: ${{ github.event.inputs.draft_release }}
        run: |
          release_notes=$(printf "Automated release for version %s.\\nBuilt from branch: \`%s\`\\nCommit: \`%s\`" "$NEW_VERSION" "$BRANCH_NAME" "$COMMIT_SHA_SHORT")
          
          # Write release notes to a file
          printf "%s" "$release_notes" > release_notes.txt

          # Collect asset files
          asset_args=()
          while IFS= read -r -d $'\0' file; do
            asset_args+=("$file")
          done < asset_files.txt

          echo "Debug: Release notes file content:"
          cat release_notes.txt
          echo "Debug: Files to attach to release:"
          printf "'%s'\n" "${asset_args[@]}"

          gh release create "$NEW_VERSION" \
            --repo "$GITHUB_REPOSITORY" \
            --title "Release $NEW_VERSION" \
            --notes-file release_notes.txt \
            --target "$GITHUB_SHA" \
            $( [[ "$IS_PRERELEASE" == "true" ]] && echo "--prerelease" ) \
            $( [[ "$DRAFT_RELEASE" == "true" ]] && echo "--draft" ) \
            "${asset_args[@]}" 