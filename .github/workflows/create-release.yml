name: Create Release

env:
  CARGO_TERM_COLOR: always

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Type of version bump (major, minor, patch) or specify custom version. For 0.x.y releases, major will bump 0.x -> 0.(x+1)'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
          - custom
      custom_version:
        description: 'Custom version string (e.g., v1.2.3 or v0.2.1-beta.1). Only used if version_type is "custom". MUST start with "v" (e.g. v1.2.3)'
        required: false
      is_prerelease:
        description: 'Is this a pre-release? (e.g., alpha, beta, rc)'
        required: true
        type: boolean
        default: false
      prerelease_identifier:
        description: 'Pre-release identifier (e.g., alpha, beta, rc). Only used if is_prerelease is true.'
        required: false
        default: 'rc'
      draft_release:
        description: 'Create the release as a draft?'
        required: true
        type: boolean
        default: true
      fast_test_create_release_job:
        description: 'If true, skips actual build and uses dummy artifacts to test release creation steps.'
        required: false
        type: boolean
        default: false

jobs:
  calculate_next_version:
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.versioner.outputs.new_version }}
      commit_sha_short: ${{ steps.vars.outputs.commit_sha_short }}
      branch_name: ${{ steps.vars.outputs.branch_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get current branch and commit SHA
        id: vars
        run: |
          echo "commit_sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "branch_name=$(git rev-parse --abbrev-ref HEAD)" >> $GITHUB_OUTPUT

      - name: Get latest tag
        id: latest_tag
        run: |
          latest_semver_tag=$(git describe --tags --match "v[0-9]*.[0-9]*.[0-9]*" --abbrev=0 2>/dev/null || echo "v0.0.0")
          if [[ "$latest_semver_tag" == "v0.0.0" ]]; then
            latest_semver_tag=$(git describe --tags --match "v*" --abbrev=0 2>/dev/null | sed 's/-\(alpha\|beta\|rc\)\(\.[0-9]*\)?$//' || echo "v0.0.0")
          fi
          echo "latest_tag_found=$latest_semver_tag" >> $GITHUB_OUTPUT
          echo "Latest semantic version tag found: $latest_semver_tag"

      - name: Calculate new version
        id: versioner
        env:
          LATEST_TAG: ${{ steps.latest_tag.outputs.latest_tag_found }}
          VERSION_TYPE: ${{ github.event.inputs.version_type }}
          CUSTOM_VERSION: ${{ github.event.inputs.custom_version }}
          IS_PRERELEASE: ${{ github.event.inputs.is_prerelease }}
          PRERELEASE_ID: ${{ github.event.inputs.prerelease_identifier }}
        run: |
          current_version=${LATEST_TAG#v}
          if [[ "$VERSION_TYPE" == "custom" ]]; then
            if [[ -z "$CUSTOM_VERSION" ]]; then
              echo "Error: Custom version is selected but no custom_version string provided."
              exit 1
            fi
            if [[ ! "$CUSTOM_VERSION" =~ ^v ]]; then
              echo "Error: Custom version string MUST start with 'v' (e.g., v1.2.3)."
              exit 1
            fi
            new_version="$CUSTOM_VERSION"
          else
            IFS='-' read -r version_core prerelease_part <<< "$current_version"
            IFS='.' read -r major minor patch <<< "$version_core"
            if [[ "$VERSION_TYPE" == "major" ]]; then
              if [[ "$major" == "0" ]]; then
                minor=$((minor + 1))
                patch=0
              else
                major=$((major + 1))
                minor=0
                patch=0
              fi
            elif [[ "$VERSION_TYPE" == "minor" ]]; then
              minor=$((minor + 1))
              patch=0
            elif [[ "$VERSION_TYPE" == "patch" ]]; then
              patch=$((patch + 1))
            else
              echo "Error: Invalid version_type: $VERSION_TYPE"
              exit 1
            fi
            new_version_core="v$major.$minor.$patch"
            if [[ "$IS_PRERELEASE" == "true" ]]; then
              prerelease_num=1
              if [[ "$prerelease_part" =~ ^$PRERELEASE_ID\.([0-9]+)$ ]]; then
                prerelease_num=1
              elif [[ "$prerelease_part" =~ ^$PRERELEASE_ID$ ]]; then
                prerelease_num=1
              fi
              new_version="$new_version_core-$PRERELEASE_ID.$prerelease_num"
            else
              new_version="$new_version_core"
            fi
          fi
          echo "New version: $new_version"
          echo "new_version=$new_version" >> $GITHUB_OUTPUT

  build_and_package:
    needs: calculate_next_version
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
          - target: aarch64-apple-darwin
            os: macos-latest
          - target: x86_64-pc-windows-msvc
            os: windows-latest
    outputs:
      release_assets_json: ${{ steps.prepare_assets.outputs.release_assets_json }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install protoc (protobuf-compiler) for Linux
        if: runner.os == 'Linux'
        run: sudo apt-get update && sudo apt-get install -y protobuf-compiler

      - name: Install protoc (protobuf-compiler) for macOS
        if: runner.os == 'macOS'
        run: brew install protobuf

      - name: Install protoc (protobuf-compiler) for Windows
        if: runner.os == 'Windows'
        run: choco install protoc --yes --no-progress
        # Using --yes to auto-confirm and --no-progress to reduce log spam

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: nightly-2024-12-24
          components: rustfmt, clippy, rust-src
          targets: wasm32-unknown-unknown, ${{ matrix.target }}

      - name: Create dummy quantus-node binary (for fast test)
        if: github.event.inputs.fast_test_create_release_job == 'true'
        shell: bash # Keep bash for Linux/macOS, override for Windows below
        run: |
          mkdir -p target/${{ matrix.target }}/release
          echo "This is a dummy quantus-node for fast testing (${{ matrix.target }}). Actual build skipped." > target/${{ matrix.target }}/release/quantus-node
          chmod +x target/${{ matrix.target }}/release/quantus-node
          echo "Dummy quantus-node created at target/${{ matrix.target }}/release/quantus-node"

      - name: Create dummy quantus-node.exe binary (for fast test Windows)
        if: github.event.inputs.fast_test_create_release_job == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $dummy_path = "target/${{ matrix.target }}/release"
          New-Item -ItemType Directory -Path $dummy_path -Force | Out-Null
          Set-Content -Path "$dummy_path/quantus-node.exe" -Value "This is a dummy quantus-node.exe for fast testing (${{ matrix.target }}). Actual build skipped."
          Write-Host "Dummy quantus-node.exe created at $dummy_path/quantus-node.exe"

      - name: Prepare Release Assets
        id: prepare_assets
        env:
          NEW_VERSION: ${{ needs.calculate_next_version.outputs.new_version }}
          TARGET_ARCH: ${{ matrix.target }}
        shell: bash # Default shell, override for Windows specific commands if needed or use 'if' conditions
        run: |
          NODE_BASE_NAME="quantus-node"
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            NODE_EXECUTABLE_NAME="${NODE_BASE_NAME}.exe"
            ARCHIVE_EXTENSION="zip"
          else
            NODE_EXECUTABLE_NAME="${NODE_BASE_NAME}"
            ARCHIVE_EXTENSION="tar.gz"
          fi

          asset_name="${NODE_BASE_NAME}-${NEW_VERSION}-${TARGET_ARCH}.${ARCHIVE_EXTENSION}"
          checksum_file_name="sha256sums-${NEW_VERSION}-${TARGET_ARCH}.txt"

          mkdir staging
          cp "target/${TARGET_ARCH}/release/${NODE_EXECUTABLE_NAME}" "staging/"
          
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            # PowerShell for zipping
            powershell -Command "Compress-Archive -Path staging/${NODE_EXECUTABLE_NAME} -DestinationPath ${asset_name}"
            # PowerShell for checksum
            powershell -Command "(Get-FileHash -Algorithm SHA256 '${asset_name}').Hash.ToLower() + ' *${asset_name}' | Set-Content -Encoding ascii '${checksum_file_name}'"
          else
            (cd staging && tar -czvf "../${asset_name}" "${NODE_EXECUTABLE_NAME}")
            if [[ "${{ runner.os }}" == "macOS" ]]; then
              shasum -a 256 "${asset_name}" > "${checksum_file_name}"
            else
              sha256sum "${asset_name}" > "${checksum_file_name}"
            fi
          fi
          
          echo "Created asset: ${asset_name}"
          echo "Created checksum file: ${checksum_file_name}"

          asset_paths_json="[\"${asset_name}\", \"${checksum_file_name}\"]"
          echo "release_assets_json=${asset_paths_json}" >> $GITHUB_OUTPUT
          ls -la


      - name: Upload Release Assets as Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-assets-${{ matrix.target }} # This is the artifact name for this specific OS/target build
          # These paths are generated in the "Prepare Release Assets" step
          path: |
            quantus-node-${{ needs.calculate_next_version.outputs.new_version }}-${{ matrix.target }}.${{ runner.os == 'Windows' && 'zip' || 'tar.gz' }}
            sha256sums-${{ needs.calculate_next_version.outputs.new_version }}-${{ matrix.target }}.txt

  create_github_release:
    needs: [calculate_next_version, build_and_package]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}

      - name: Download all release assets
        uses: actions/download-artifact@v4
        with:
          path: downloaded-artifacts

      - name: Generate asset list file
        run: |
          echo "--- Directory structure of downloaded-artifacts ---"
          ls -R downloaded-artifacts
          echo "--- Finding asset files ---"
          bash -c 'find downloaded-artifacts -type f \( -name "*.tar.gz" -o -name "*.zip" -o -name "*.txt" \) -print0' > asset_files.txt
          echo "--- Raw content of asset_files.txt (null characters will not be visible) ---"
          cat asset_files.txt 
          echo "--- Processed content of asset_files.txt (one file per line) ---"
          cat asset_files.txt | xargs -0 -n1
          echo "--- End of Generate asset list file step ---"

      - name: Create Git Tag
        env:
          NEW_VERSION: ${{ needs.calculate_next_version.outputs.new_version }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"
          git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
          git push origin "$NEW_VERSION"

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NEW_VERSION: ${{ needs.calculate_next_version.outputs.new_version }}
          COMMIT_SHA_SHORT: ${{ needs.calculate_next_version.outputs.commit_sha_short }}
          BRANCH_NAME: ${{ needs.calculate_next_version.outputs.branch_name }}
          IS_PRERELEASE: ${{ github.event.inputs.is_prerelease }}
          DRAFT_RELEASE: ${{ github.event.inputs.draft_release }}
        run: |
          release_notes=$(printf "Automated release for version %s.\\nBuilt from branch: \`%s\`\\nCommit: \`%s\`" "$NEW_VERSION" "$BRANCH_NAME" "$COMMIT_SHA_SHORT")
          printf "%s" "$release_notes" > release_notes.txt

          asset_args=()
          while IFS= read -r -d $'\0' file; do
            asset_args+=("$file")
          done < asset_files.txt

          echo "Debug: Release notes file content:"
          cat release_notes.txt
          echo "Debug: Files to attach to release:"
          printf "'%s'\n" "${asset_args[@]}"

          gh release create "$NEW_VERSION" \
            --repo "$GITHUB_REPOSITORY" \
            --title "Release $NEW_VERSION" \
            --notes-file release_notes.txt \
            --target "$GITHUB_SHA" \
            $( [[ "$IS_PRERELEASE" == "true" ]] && echo "--prerelease" ) \
            $( [[ "$DRAFT_RELEASE" == "true" ]] && echo "--draft" ) \
            "${asset_args[@]}"